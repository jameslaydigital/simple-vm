#!/usr/bin/python
import re
from optparse import OptionParser

parser = OptionParser()
parser.add_option("-o", "--output", dest="outputFile", help="Assemble output to FILE", metavar="FILE")
parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="Verbose output.")
(options, args) = parser.parse_args()
sourceFile = args[0] if len(args) > 0 else ""
outputFile = options.outputFile
outputFile = outputFile if outputFile else "a.out"
verbose = options.verbose
if not sourceFile:
    print "No source file specified. Usage: asm source_file"
    exit(1)

################# DEFS #########################################
INSTRUCTION_LENGTH = 8

################# TYPES ########################################

class Operation(object):
    def __init__(self, name, arguments, lineNum=0):
        self.name = name
        if not name in ops:
            err("Operation not found: \""+name+"\"", lineNum)
        self.arguments = arguments
        self.lineNum = lineNum
        argTypes = " ".join([type(arg).__name__ for arg in arguments])
        if argTypes in ops[name]:
            self.value = ops[name][argTypes]
        else:
            err("Incorrect argument pattern for nmemonic \""+name+"\". " +
                "Acceptable argument patterns are: \n" + argTypes, lineNum)
        self.argumentTypes = argTypes
    def toString(self):
        return self.name+"("+', '.join([arg.toString() for arg in self.arguments])+")"
    def compile(self):
        compilation = self.value+"".join([arg.compile() for arg in self.arguments])
        length = len(compilation)
        diff = 8-length
        zeroPadding = "\x00"*diff
        return compilation+zeroPadding


class Reg(object):
    def __init__(self, name, line):
        self.name = name
        if name in registers:
            self.value = registers[name]
        else:
            err("Cannot instantiate Reg object; \""+name+"\" not found in register table.", line)
    def toString(self):
        return "<Reg "+self.name+">"
    def compile(self):
        return self.value

class IndReg(object):
    def __init__(self, name, lineNum):
        self.name = name
        if name in registers:
            self.value = registers[name]
        else:
            err("Cannot instantiate IndReg object; \""+name+"\" not found in register table.", line)
    def toString(self):
        return "<Reg "+self.name+">"
    def compile(self):
        return self.value

class Const(object):
    def __init__(self, token, lineNum):
        self.lineNum = lineNum
        match = re.match(r"^\d+$", token)
        if match != None:
            self.value = int(token)
            return
        match = re.match(r"^(0x)([0-9a-fA-F]+)$", token)
        if match != None:
            self.value = int(token, 16)
            return
        match = re.match(r"^(0b)([01]+)$", token)
        if match != None:
            self.value = int(token, 2)
            return
    def toString(self):
        return "<Const "+str(self.value)+">"
    def compile(self):
        #TODO: if self.value > 255, two bytes. If > 65535, 4 bytes
        return chr(self.value)+"\x00"
class IndConst(object):
    def __init__(self, token, lineNum):
        self.value = int(token)
        self.lineNum = lineNum
    def toString(self):
        return "<IndConst "+str(self.value)+">"
    def compile(self):
        #TODO: if self.value > 255, two bytes. If > 65535, 4 bytes
        if self.value < 256:
            return chr(self.value)+"\x00\x00\x00"
        if self.value < 65536:
            return chr(self.value & 0xff) + chr((self.value >> 8) & 0xff) + "\x00\x00"
        return chr(self.value&0xff)+chr((self.value>>8)&0xff)+chr((self.value>>16)&0xff)+chr((self.value>>24)&0xff)



class SysCall(object):
    def __init__(self, token, lineNum):
        self.name = token
        if token in syscalls:
            self.value = syscalls[token]
        else:
            err("Syscall does not exist: \""+token+"\".", lineNum)
    def toString(self):
        return "<SysCall "+self.name+">"
    def compile(self):
        return self.value

################# UTILS ########################################
def err(msg, line):
    print msg + " on line "+str(line+1)+"."
    exit(1)

################# TABLES #######################################
ops = {
    "debug" : {
        "Const Const Const" : "\x00\x00"
    },
    "mov" : {
        "Reg Reg"       :"\x01\x00",
        "Reg Const"     :"\x02\x00",
        "Reg IndConst"  :"\x03\x00",
        "Reg IndReg"    :"\x04\x00",
        "IndReg Reg"    :"\x05\x00",
        "IndReg Const"  :"\x06\x00",
        "IndConst Reg"  :"\x07\x00"
        #"IndConst Const":"\x08\x00" instr size limitation
    },
    "label" : {
        "Name" : "\0"
    },
    "noop" : {
        ""  :"\x08\x00"
    },
    "jump" : {
        "Const" : "\x09\x00\x00\x00"
    },
    "jumpE" : {
        "Const" : "\x0a\x00\x00\x00"
    },
    "jumpNE" : {
        "Const" : "\x0b\x00\x00\x00"
    },
    "jumpLT" : {
        "Const" : "\x0c\x00\x00\x00"
    },
    "jumpGT" : {
        "Const" : "\x0d\x00\x00\x00"
    },
    "cmpRegReg" : {
        "Reg Reg" : "\x0e\x00"
    },
    "cmpRegConst" : {
        "Reg Const" : "\x0f\x00"
    },
    "push" : {
        "Reg" : "\x11\x00",
        "Const" : "\x12\x00\x00\x00"
    },
    "pop" : {
        "Reg" : "\x13\x00"
    },
    "xor" : {
        "Reg Reg" : "\x14\x00",
        "Reg Const" : "\x15\x00"
    },
    "lshift" : {
        "Reg Reg" : "\x16\x00",
        "Reg Const" : "\x17\x00"
    },
    "rshift" : {
        "Reg Reg" : "\x18\x00",
        "Reg Const" : "\x19\x00"
    },
    "and" : {
        "Reg Reg" : "\x1a\x00",
        "Reg Const" : "\x1b\x00"
    },
    "not" : {
        "Reg" : "\x1c\x00"
    },
    "add" : {
        "Reg Reg" : "\x1d\x00",
        "Reg Const" : "\x1e\x00"
    },
    "sub" : {
        "Reg Reg" : "\x1f\x00",
        "Reg Const" : "\x20\x00"
    },
    "mult" : {
        "Reg Reg" : "\x21\x00",
        "Reg Const" : "\x22\x00"
    },
    "div" : {
        "Reg Reg" : "\x23\x00",
        "Reg Const" : "\x24\x00"
    },
    "syscall" : {
        "SysCall" : "\x10\x00\x00\x00"
    },
    "db" : {
        "Const Const Const Const" : ""
    }
}

syscalls = {
    "dump"  : "\x00\x00",
    "exit"  : "\x01\x00",
    "print" : "\x02\x00"
}

registers = {
    "R0" : "\x00\x00",
    "R1" : "\x01\x00",
    "R2" : "\x02\x00",
    "R3" : "\x03\x00",
    "R4" : "\x04\x00",
    "R5" : "\x05\x00",
    "R6" : "\x06\x00",
    "R7" : "\x07\x00",
    "R8" : "\x08\x00",
    "R9" : "\x09\x00",
    "R10": "\x0a\x00",
    "BP" : "\x0a\x00",
    "SP" : "\x0b\x00"
}

################# AST ##########################################
class AST(object):
    def __init__(self, source):
        self.source = source
        self.astSequence = []
        for i in range(len(source)):
            tokens = source[i]
            arguments = [self.identify(token,i) for token in tokens[1:]] if len(tokens) > 1 else []
            op = Operation(tokens[0], arguments, i) #name, arguments, line#
            self.astSequence.append(op)

    def identify(self, token, line, arguments=[]):
        if token[0] == '[' and token[-1] == ']':
            key = token[1:-1]
            if key in registers:
                return IndReg(key, line)
            else:
                return IndConst(key, line)
        else:
            if token in registers:
                return Reg(token, line)
            if token in syscalls:
                return SysCall(token, line)
            if token in labels:
                return Const(str(labels[token]), line)
            if tokIsNumber(token):
                return Const(token, line)
            err("Unrecognized token: \""+token+"\"", line)
    def toString(self):
        return "{\n\t"+",\n\t".join([op.toString() for op in self.astSequence])+"\n}"
    def compile(self):
        #1st pass: proc labels...
        return "".join([op.compile() for op in self.astSequence])

def tokIsNumber(string):
    if re.match(r"^0x[0-9a-fA-F]+$", string) != None:
        return True
    if re.match(r"^0b[01]+$", string) != None:
        return True
    if re.match(r"^\d+$", string) != None:
        return True
    return False

################# ENTRY POINT ##################################
#sourceData = [line.split() for line in open(sourceFile).readlines()]

fdata = open(sourceFile).read()

#LABEL PREPROCESSOR
#start by giving labels their own line
flines = re.sub(r"\n *(.[a-zA-Z0-9.]+):", r"\nlabel \1\n", fdata).split("\n")
print "\n".join(flines)
labels = {}
i = 0
while i < len(flines):
    line = flines[i]
    nocmt = line.split(";").pop(0).strip() #rm comments
    if nocmt == "": #ignore whitespace and empties
        flines.pop(i) #get rid of it so it doesn't fuck our line count
    else:
        toks = line.split()
        print str(toks)
        if toks[0] == "label":
            if len(toks) == 1:
                err("Label has no name.", i)
            labels[toks[1]] = i*INSTRUCTION_LENGTH
            flines.pop(i)
            i -= 1
        i += 1

#PARSER
sourceData = []
for line in flines:
    nocmt = line.split(";").pop(0).strip() #rm comments
    if nocmt != "": #ignore whitespace and empties
        sourceData.append(nocmt.split())

ast = AST(sourceData)
if verbose: print ast.toString()
open(outputFile, "wb").write(ast.compile())
